package manipcli

import (
	"crypto/x509"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"reflect"
	"regexp"
	"runtime"
	"strings"

	"github.com/araddon/dateparse"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"go.aporeto.io/elemental"
	"go.aporeto.io/manipulate"
	"go.uber.org/zap"
)

// prepareAPICACertPool prepares the API cert pool if not empty.
func prepareAPICACertPool(capath string) (*x509.CertPool, error) {

	if capath == "" {
		if runtime.GOOS == "windows" {
			// use nil as RootCAs on Windows in order to call systemVerify,
			// which will work even if Windows has not cached all its root certs.
			return nil, nil
		}
		return x509.SystemCertPool()
	}

	capool := x509.NewCertPool()
	cadata, err := os.ReadFile(capath)
	if err != nil {
		return nil, err
	}

	capool.AppendCertsFromPEM(cadata)

	return capool, nil
}

// shouldManageAttribute indicates if the attribute should be managed or not.
func shouldManageAttribute(spec elemental.AttributeSpecification) bool {

	if !spec.Exposed {
		return false
	}

	if spec.PrimaryKey {
		return false
	}

	if spec.Autogenerated {
		return false
	}

	if spec.ReadOnly {
		return false
	}

	return true
}

// ParametersToURLValues converts the list of `key=value` to url.Values.
func parametersToURLValues(params []string) (url.Values, error) {

	values := url.Values{}
	for _, keyVal := range params {

		kV := strings.SplitN(keyVal, "=", 2)

		if len(kV) != 2 {
			return nil, fmt.Errorf("invalid parameter %s", keyVal)
		}

		values.Add(kV[0], kV[1])
	}

	return values, nil
}

// validateOutputParameters validates output parameters are correct
func validateOutputParameters(output string) error {

	// Check output constraints
	allOutputOptions := []string{
		flagOutputTable,
		flagOutputJSON,
		flagOutputNone,
		flagOutputDefault,
		flagOutputYAML,
		flagOutputTemplate,
	}

	for _, opt := range allOutputOptions {
		if opt == output {
			return nil
		}
	}

	return fmt.Errorf("invalid output %s", output)
}

// retrieveByIDOrByName retrieves an object from its id or name
func retrieveObjectByIDOrByName(
	ctx manipulate.Context,
	manipulator manipulate.Manipulator,
	identity elemental.Identity,
	idOrName string,
	modelManager elemental.ModelManager,
) (elemental.Identifiable, error) {

	identifiable := modelManager.IdentifiableFromString(identity.Name)
	identifiable.SetIdentifier(idOrName)

	if _, err := hex.DecodeString(identifiable.Identifier()); err == nil {
		if err := manipulator.Retrieve(ctx, identifiable); err != nil {
			return nil, err
		}
		return identifiable, nil
	}

	// let's try to find the object by name
	var dest elemental.Identifiables
	if _, ok := identifiable.(elemental.SparseIdentifiable); ok {
		dest = modelManager.SparseIdentifiables(identifiable.Identity())
	} else {
		dest = modelManager.Identifiables(identifiable.Identity())
	}

	mctx := ctx.Derive(
		manipulate.ContextOptionFilter(
			elemental.NewFilter().
				WithKey("name").Equals(identifiable.Identifier()).
				Done(),
		),
	)

	if err := manipulator.RetrieveMany(mctx, dest); err != nil {
		return nil, err
	}

	lst := dest.List()

	if len(lst) == 0 {
		return nil, fmt.Errorf("no %s found with id or name %s", identifiable.Identity().Name, idOrName)
	}

	if len(lst) > 1 {
		return nil, fmt.Errorf("more than one %s has been found with id or name %s. Use ID", identifiable.Identity().Name, idOrName)
	}

	return lst[0], nil
}

// readViperFlags reads all viper flags and fill the identifiable properties.
// TODO: Make it better and add more types here.
func readViperFlags(identifiable elemental.Identifiable) error {

	if identifiable == nil {
		return fmt.Errorf("provided identifiable is nil")
	}
	specifiable, ok := identifiable.(elemental.AttributeSpecifiable)
	if !ok {
		return fmt.Errorf("%s is not an AttributeSpecifiable", identifiable.Identity().Name)
	}

	rv := reflect.ValueOf(identifiable).Elem()

	for _, spec := range specifiable.AttributeSpecifications() {

		if !shouldManageAttribute(spec) {
			continue
		}

		flagName := nameToFlag(spec.Name)
		if !viper.IsSet(flagName) {
			continue
		}

		fv := rv.FieldByName(spec.ConvertedName)

		switch spec.Type {
		case "string", "enum":
			fv.SetString(viper.GetString(flagName))

		case "float64":
			fv.SetFloat(viper.GetFloat64(flagName))

		case "boolean":
			fv.SetBool(viper.GetBool(flagName))

		case "integer":
			fv.SetInt(viper.GetInt64(flagName))

		case "time":
			t, err := dateparse.ParseAny(viper.GetString(flagName))
			if err != nil {
				return err
			}
			fv.Set(reflect.ValueOf(t))

		default:
			rt := reflect.TypeOf(specifiable.ValueForAttribute(flagName))
			rv := reflect.New(rt)
			if err := json.Unmarshal([]byte(viper.GetString(flagName)), rv.Interface()); err != nil {
				return err
			}
			fv.Set(rv.Elem())
		}
	}

	return nil
}

// setViperFlags sets the viper flags to the command according to the identifiable
// TODO: Make it better and add more types here.
func setViperFlags(cmd *cobra.Command, identifiable elemental.Identifiable, forceRequired bool) error {

	if cmd == nil {
		return fmt.Errorf("provided command is nil")
	}

	if identifiable == nil {
		return fmt.Errorf("provided identifiable is nil")
	}

	specifiable, ok := identifiable.(elemental.AttributeSpecifiable)
	if !ok {
		return fmt.Errorf("%s is not an AttributeSpecifiable", identifiable.Identity().Name)
	}

	for _, spec := range specifiable.AttributeSpecifications() {

		if !shouldManageAttribute(spec) {
			continue
		}

		flagName := nameToFlag(spec.Name)

		// Register flag based on type
		switch spec.Type {

		case "string":
			cmd.Flags().StringP(flagName, "", "", spec.Description)

		case "enum":
			cmd.Flags().StringP(flagName, "", "", spec.Description)

		case "float64":
			cmd.Flags().Float64P(flagName, "", 0, spec.Description)

		case "boolean":
			cmd.Flags().BoolP(flagName, "", false, spec.Description)

		case "integer":
			cmd.Flags().IntP(flagName, "", 0, spec.Description)

		case "time":
			cmd.Flags().StringP(flagName, "", "", spec.Description)

		default:
			zap.L().Debug("use default type string for attribute", zap.String("attribute", spec.Name), zap.String("identity", identifiable.Identity().Name))
			cmd.Flags().StringP(flagName, "", "", spec.Description)
		}

		if forceRequired && spec.Required {
			if err := cmd.MarkFlagRequired(flagName); err != nil {
				return fmt.Errorf("unable to mark flag %s as required", flagName)
			}
		}
	}

	return nil
}

var matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
var matchAllCap = regexp.MustCompile("([a-z0-9])([A-Z])")

func nameToFlag(name string) string {
	flag := matchFirstCap.ReplaceAllString(name, "${1}-${2}")
	flag = matchAllCap.ReplaceAllString(flag, "${1}-${2}")
	return strings.ToLower(flag)
}
